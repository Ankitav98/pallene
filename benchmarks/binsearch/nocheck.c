/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

static lua_Integer function_binsearch_pallene(
    lua_State * L,
    Table * x1 /* t */,
    lua_Integer x2 /* x */
){
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        lua_Integer x6 /* lo */ = 1;
        lua_Integer x7 = luaH_getn(x1);
        lua_Integer x8 /* hi */ = x7;
        lua_Integer x9 /* steps */ = 0;
        for(;;) {
            int x10 = x6 < x8;
            if (!x10) break;
            {
                lua_Integer x11 = intop(-, x8, x6);
                lua_Integer x12;
                if (l_castS2U(2) + 1u <= 1u) {
                    if (2 == 0){
                        pallene_runtime_divide_by_zero_error(L, 10);
                    } else {
                        x12 = intop(-, 0, x11);
                    }
                } else {
                    x12 = x11 / 2;
                    if ((x11 ^ 2) < 0 && x11 % 2 != 0) {
                        x12 -= 1;
                    }
                }
                lua_Integer x13 = intop(+, x6, x12);
                lua_Integer x14 /* mid */ = x13;
                lua_Integer x15 = intop(+, x9, 1);
                x9 = x15;
                lua_Unsigned x16 /* ui */ = ((lua_Unsigned)x14) - 1;
                if (PALLENE_UNLIKELY(x16 >= x1->sizearray)) {
                    pallene_renormalize_array(L, x1, x16, 13);
                }
                const TValue * x17 /* arrslot */ = &x1->array[x16];
                lua_Integer x18 = ivalue(x17);
                lua_Integer x19 /* tmid */ = x18;
                {
                    int x20 = x2 == x19;
                    if (x20) {
                        return x9;
                    } else {
                        int x21 = x2 < x19;
                        if (x21) {
                            lua_Integer x22 = intop(-, x14, 1);
                            x8 = x22;
                        } else {
                            lua_Integer x23 = intop(+, x14, 1);
                            x6 = x23;
                        }
                    }
                }
            }
        }
        return x9;
    }
}

static int function_binsearch_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    Table * x8 = hvalue(s2v(x4 + 1));
    lua_Integer x9 = ivalue(s2v(x4 + 2));
    lua_Integer x10 /* ret */ = function_binsearch_pallene(L, x8, x9);
    setivalue(s2v(L->top), x10);
    api_incr_top(L);
    return 1;
}

static lua_Integer function_test_pallene(
    lua_State * L,
    Table * x1 /* t */,
    lua_Integer x2 /* nrep */
){
    lua_checkstack(L, 1);
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        lua_Integer x6 /* s */ = 0;
        lua_Integer x7 /* start */ = 1;
        lua_Integer x8 /* limit */ = x2;
        lua_Integer x9 /* step */ = 1;
        while ((x9 >= 0 ? x7 <= x8 : x7 >= x8)) {
            lua_Integer x10 /* i */ = x7;
            (void) x10;
            {
                {
                    StackValue* x11 = L->top;
                    sethvalue(L, s2v(x11), x1); x11++;
                    L->top = x11;
                    lua_Integer x12 = function_binsearch_pallene(L, x1, x10);
                    L->top -= 1;
                    int x13 = x12 != 22;
                    if (x13) {
                        lua_Integer x14 = intop(+, x6, 1);
                        x6 = x14;
                    } else {
                    }
                }
            }
            x7 = intop(+, x7, x9);
        }
        return x6;
    }
}

static int function_test_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    Table * x8 = hvalue(s2v(x4 + 1));
    lua_Integer x9 = ivalue(s2v(x4 + 2));
    lua_Integer x10 /* ret */ = function_test_pallene(L, x8, x9);
    setivalue(s2v(L->top), x10);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_binsearch_nocheck(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 5);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* binsearch */
    CClosure* x6 = luaF_newCclosure(L, 1);
    x6->f = function_binsearch_lua;
    setuvalue(L, &x6->upvalue[0], x1);
    TValue x7; setclCvalue(L, &x7, x6);
    setobj(L,  &x2[3].uv , &x7);
    if (iscollectable(&x7) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x7))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* test */
    CClosure* x8 = luaF_newCclosure(L, 1);
    x8->f = function_test_lua;
    setuvalue(L, &x8->upvalue[0], x1);
    TValue x9; setclCvalue(L, &x9, x8);
    setobj(L,  &x2[4].uv , &x9);
    if (iscollectable(&x9) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x9))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x10 = L->top;
    setuvalue(L, s2v(x10), x1); x10++;
    L->top = x10;
    lua_createtable(L, 0, 2);
    lua_pushstring(L, "binsearch");
    setobj(L, s2v(L->top),  &x2[3].uv ); api_incr_top(L);
    lua_settable(L, -3);
    lua_pushstring(L, "test");
    setobj(L, s2v(L->top),  &x2[4].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

