/*
 *  This implements some manual optimizations that the pallene compiler
 *  currently cannot. See "HANDOPT.txt".
 */

/*
 *  This file also removes all safety tag checks.
 */

/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

static int function_isplaceok_pallene(
    lua_State * L,
    Table * x1 /* a */,
    lua_Integer x2 /* n */,
    lua_Integer x3 /* c */
){
    CClosure * x4 = clCvalue(s2v(L->ci->func));
    Udata * x5 /* upvalue table */ = uvalue(&x4->upvalue[0]);
    UValue * x6 /* upvalue array */ = x5->uv;
    (void)x6;
    {
        lua_Integer x8 = intop(-, x2, 1);
        lua_Integer x7 /* start */ = 1;
        lua_Integer x9 /* limit */ = x8;
        lua_Integer x10 /* step */ = 1;

        /* BEGIN OPT - bounds for a[i]*/
        if (x9 >= x7) {
            lua_Unsigned bound = ((lua_Unsigned)x9) - 1;
            if (PALLENE_UNLIKELY(bound >= x1->sizearray)) {
                pallene_renormalize_array(L, x1, bound, 4);
            }
        }
        /* END OPT */
        while ((x10 >= 0 ? x7 <= x9 : x7 >= x9)) {
            lua_Integer x11 /* i */ = x7;
            (void) x11;
            {
                lua_Unsigned x12 /* ui */ = ((lua_Unsigned)x11) - 1;
                const TValue * x13 /* arrslot */ = &x1->array[x12];
                lua_Integer x14 = ivalue(x13);
                lua_Integer x15 /* d */ = x14;
                {
                    int x16 = x15 == x3;
                    int x17 = x16;
                    if (!x17) {
                        lua_Integer x18 = intop(-, x15, x11);
                        lua_Integer x19 = intop(-, x3, x2);
                        int x20 = x18 == x19;
                        x17 = x20;
                    }
                    int x21 = x17;
                    if (!x21) {
                        lua_Integer x22 = intop(+, x15, x11);
                        lua_Integer x23 = intop(+, x3, x2);
                        int x24 = x22 == x23;
                        x21 = x24;
                    }
                    if (x21) {
                        return 0;
                    } else {
                    }
                }
            }
            x7 = intop(+, x7, x10);
        }
        return 1;
    }
}

static int function_isplaceok_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    Table * x9 = hvalue(s2v(x4 + 1));
    lua_Integer x10 = ivalue(s2v(x4 + 2));
    lua_Integer x11 = ivalue(s2v(x4 + 3));
    int x12 /* ret */ = function_isplaceok_pallene(L, x9, x10, x11);
    setbvalue(s2v(L->top), x12);
    api_incr_top(L);
    return 1;
}

static void function_printsolution_pallene(
    lua_State * L,
    lua_Integer x1 /* N */,
    Table * x2 /* a */
){
    CClosure * x3 = clCvalue(s2v(L->ci->func));
    Udata * x4 /* upvalue table */ = uvalue(&x3->upvalue[0]);
    UValue * x5 /* upvalue array */ = x4->uv;
    (void)x5;
    {
        lua_Integer x6 /* start */ = 1;
        lua_Integer x7 /* limit */ = x1;
        lua_Integer x8 /* step */ = 1;

        /* BEGIN OPT - bounds for a[i]*/
        if (x7 >= x6) {
            lua_Unsigned bound = ((lua_Unsigned)x7) - 1;
            if (PALLENE_UNLIKELY(bound >= x2->sizearray)) {
                pallene_renormalize_array(L, x2, bound, 18);
            }
        }
        /* END OPT */
        while ((x8 >= 0 ? x6 <= x7 : x6 >= x7)) {
            lua_Integer x9 /* i */ = x6;
            (void) x9;
            {
                lua_Unsigned x10 /* ui */ = ((lua_Unsigned)x9) - 1;
                const TValue * x11 /* arrslot */ = &x2->array[x10];
                lua_Integer x12 = ivalue(x11);
                lua_Integer x13 /* ai */ = x12;
                lua_Integer x14 /* start */ = 1;
                lua_Integer x15 /* limit */ = x1;
                lua_Integer x16 /* step */ = 1;
                while ((x16 >= 0 ? x14 <= x15 : x14 >= x15)) {
                    lua_Integer x17 /* j */ = x14;
                    (void) x17;
                    {
                        {
                            int x18 = x13 == x17;
                            if (x18) {
                                TValue * x19 =  &x5[3].uv ;
                                TString * x20 = tsvalue(x19);
                                FILE * x21 = stdout; /* TODO: use Lua output file */
                                const char * x22 = getstr(x20);
                                size_t x23 = tsslen(x20);
                                fwrite(x22, sizeof(char), x23, x21);
                            } else {
                                TValue * x24 =  &x5[4].uv ;
                                TString * x25 = tsvalue(x24);
                                FILE * x26 = stdout; /* TODO: use Lua output file */
                                const char * x27 = getstr(x25);
                                size_t x28 = tsslen(x25);
                                fwrite(x27, sizeof(char), x28, x26);
                            }
                        }
                        TValue * x29 =  &x5[5].uv ;
                        TString * x30 = tsvalue(x29);
                        FILE * x31 = stdout; /* TODO: use Lua output file */
                        const char * x32 = getstr(x30);
                        size_t x33 = tsslen(x30);
                        fwrite(x32, sizeof(char), x33, x31);
                    }
                    x14 = intop(+, x14, x16);
                }
                TValue * x34 =  &x5[7].uv ;
                TString * x35 = tsvalue(x34);
                FILE * x36 = stdout; /* TODO: use Lua output file */
                const char * x37 = getstr(x35);
                size_t x38 = tsslen(x35);
                fwrite(x37, sizeof(char), x38, x36);
            }
            x6 = intop(+, x6, x8);
        }
        TValue * x39 =  &x5[7].uv ;
        TString * x40 = tsvalue(x39);
        FILE * x41 = stdout; /* TODO: use Lua output file */
        const char * x42 = getstr(x40);
        size_t x43 = tsslen(x40);
        fwrite(x42, sizeof(char), x43, x41);
    }
}

static int function_printsolution_lua(lua_State *L)
{
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    lua_Integer x8 = ivalue(s2v(x4 + 1));
    Table * x9 = hvalue(s2v(x4 + 2));
    function_printsolution_pallene(L, x8, x9);
    return 0;
}

static void function_addqueen_pallene(
    lua_State * L,
    lua_Integer x1 /* N */,
    Table * x2 /* a */,
    lua_Integer x3 /* n */
){
    lua_checkstack(L, 1);
    CClosure * x4 = clCvalue(s2v(L->ci->func));
    Udata * x5 /* upvalue table */ = uvalue(&x4->upvalue[0]);
    UValue * x6 /* upvalue array */ = x5->uv;
    (void)x6;
    {
        {
            int x7 = x3 > x1;
            if (x7) {
                StackValue* x8 = L->top;
                sethvalue(L, s2v(x8), x2); x8++;
                L->top = x8;
                function_printsolution_pallene(L, x1, x2);
                L->top -= 1;
            } else {
                lua_Integer x9 /* start */ = 1;
                lua_Integer x10 /* limit */ = x1;
                lua_Integer x11 /* step */ = 1;
                while ((x11 >= 0 ? x9 <= x10 : x9 >= x10)) {
                    lua_Integer x12 /* c */ = x9;
                    (void) x12;
                    {
                        {
                            StackValue* x13 = L->top;
                            sethvalue(L, s2v(x13), x2); x13++;
                            L->top = x13;
                            int x14 = function_isplaceok_pallene(L, x2, x3, x12);
                            L->top -= 1;
                            if (x14) {
                                lua_Unsigned x15 /* ui */ = ((lua_Unsigned)x3) - 1;
                                if (PALLENE_UNLIKELY(x15 >= x2->sizearray)) {
                                    pallene_renormalize_array(L, x2, x15, 40);
                                }
                                TValue * x16 /* slot */ = &x2->array[x15];
                                setivalue(x16, x12);
                                lua_Integer x17 = intop(+, x3, 1);
                                StackValue* x18 = L->top;
                                sethvalue(L, s2v(x18), x2); x18++;
                                L->top = x18;
                                function_addqueen_pallene(L, x1, x2, x17);
                                L->top -= 1;
                            } else {
                            }
                        }
                    }
                    x9 = intop(+, x9, x11);
                }
            }
        }
    }
}

static int function_addqueen_lua(lua_State *L)
{
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    lua_Integer x9 = ivalue(s2v(x4 + 1));
    Table * x10 = hvalue(s2v(x4 + 2));
    lua_Integer x11 = ivalue(s2v(x4 + 3));
    function_addqueen_pallene(L, x9, x10, x11);
    return 0;
}

static void function_nqueens_pallene(
    lua_State * L,
    lua_Integer x1 /* N */
){
    lua_checkstack(L, 1);
    CClosure * x2 = clCvalue(s2v(L->ci->func));
    Udata * x3 /* upvalue table */ = uvalue(&x2->upvalue[0]);
    UValue * x4 /* upvalue array */ = x3->uv;
    (void)x4;
    {
        luaC_condGC(L, {
        }, {
        });
        Table * x5 = luaH_new(L);
        luaH_resizearray(L, x5, 0);
        TValue * x6 = x5->array;
        (void) x6;
        StackValue* x7 = L->top;
        sethvalue(L, s2v(x7), x5); x7++;
        L->top = x7;
        function_addqueen_pallene(L, x1, x5, 1);
        L->top -= 1;
    }
}

static int function_nqueens_lua(lua_State *L)
{
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    lua_Integer x7 = ivalue(s2v(x4 + 1));
    function_nqueens_pallene(L, x7);
    return 0;
}

int luaopen_benchmarks_queen_nocheck(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 12);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x6 = luaS_new(L, "X");
    setsvalue(L,  &x2[3].uv , x6);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x6))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x7 = luaS_new(L, "-");
    setsvalue(L,  &x2[4].uv , x7);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x7))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x8 = luaS_new(L, " ");
    setsvalue(L,  &x2[5].uv , x8);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x8))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x9 = luaS_new(L, "\n");
    setsvalue(L,  &x2[6].uv , x9);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x9))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x10 = luaS_new(L, "\n");
    setsvalue(L,  &x2[7].uv , x10);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x10))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* isplaceok */
    CClosure* x11 = luaF_newCclosure(L, 1);
    x11->f = function_isplaceok_lua;
    setuvalue(L, &x11->upvalue[0], x1);
    TValue x12; setclCvalue(L, &x12, x11);
    setobj(L,  &x2[8].uv , &x12);
    if (iscollectable(&x12) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x12))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* printsolution */
    CClosure* x13 = luaF_newCclosure(L, 1);
    x13->f = function_printsolution_lua;
    setuvalue(L, &x13->upvalue[0], x1);
    TValue x14; setclCvalue(L, &x14, x13);
    setobj(L,  &x2[9].uv , &x14);
    if (iscollectable(&x14) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x14))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* addqueen */
    CClosure* x15 = luaF_newCclosure(L, 1);
    x15->f = function_addqueen_lua;
    setuvalue(L, &x15->upvalue[0], x1);
    TValue x16; setclCvalue(L, &x16, x15);
    setobj(L,  &x2[10].uv , &x16);
    if (iscollectable(&x16) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x16))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* nqueens */
    CClosure* x17 = luaF_newCclosure(L, 1);
    x17->f = function_nqueens_lua;
    setuvalue(L, &x17->upvalue[0], x1);
    TValue x18; setclCvalue(L, &x18, x17);
    setobj(L,  &x2[11].uv , &x18);
    if (iscollectable(&x18) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x18))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x19 = L->top;
    setuvalue(L, s2v(x19), x1); x19++;
    L->top = x19;
    lua_createtable(L, 0, 1);
    lua_pushstring(L, "nqueens");
    setobj(L, s2v(L->top),  &x2[11].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

