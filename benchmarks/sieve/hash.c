/* This file was generated by the Titan compiler. Do not edit by hand */
/* Indentation and formatting courtesy of titan-compiler/pretty.lua */

#include <string.h>

#include "tcore.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

static Table * function_sieve_titan(
    lua_State * L,
    lua_Integer x1 /* N */
){
    lua_checkstack(L, 1);
    CClosure * x2 = clCvalue(s2v(L->ci->func));
    Table * x3 /* upvalue table */ = hvalue(&x2->upvalue[0]);
    TValue * x4 /* upvalue array */ = x3->array;
    (void)x4;
    {
        luaC_condGC(L, {
        }, {
        });
        Table * x5 = luaH_new(L);
        luaH_resizearray(L, x5, 0);
        TValue * x6 = x5->array;
        (void) x6;
        Table * x7 /* is_prime */ = x5;
        lua_Unsigned x8 /* ui */ = ((lua_Unsigned)1) - 1;
        TValue * x9 /* slot */;
        if (TITAN_LIKELY(x8 < x7->sizearray)) {
            x9 = &x7->array[x8];
        } else {
            TValue x10;
            setivalue(&x10, x8+1);
            x9 = luaH_newkey(L, x7, &x10);
        }
        setbvalue(x9, 0);
        lua_Integer x11 /* start */ = 2;
        lua_Integer x12 /* finish */ = x1;
        lua_Integer x13 /* inc */ = 1;
        while ((x13 >= 0 ? x11 <= x12 : x11 >= x12)) {
            lua_Integer x14 /* n */ = x11;
            (void) x14;
            {
                lua_Unsigned x15 /* ui */ = ((lua_Unsigned)x14) - 1;
                TValue * x16 /* slot */;
                if (TITAN_LIKELY(x15 < x7->sizearray)) {
                    x16 = &x7->array[x15];
                } else {
                    TValue x17;
                    setivalue(&x17, x15+1);
                    x16 = luaH_newkey(L, x7, &x17);
                }
                setbvalue(x16, 1);
            }
            x11 = intop(+, x11, x13);
        }
        lua_Integer x18 /* nprimes */ = 0;
        luaC_condGC(L, {
            StackValue* x19 = L->top;
            sethvalue(L, s2v(x19), x7); x19++;
            L->top = x19;
        }, {
            L->top -= 1;
        });
        Table * x20 = luaH_new(L);
        luaH_resizearray(L, x20, 0);
        TValue * x21 = x20->array;
        (void) x21;
        Table * x22 /* primes */ = x20;
        lua_Integer x23 /* start */ = 1;
        lua_Integer x24 /* finish */ = x1;
        lua_Integer x25 /* inc */ = 1;
        while ((x25 >= 0 ? x23 <= x24 : x23 >= x24)) {
            lua_Integer x26 /* n */ = x23;
            (void) x26;
            {
                {
                    lua_Unsigned x27 /* ui */ = ((lua_Unsigned)x26) - 1;
                    const TValue * x28 /* arrslot */;
                    if (TITAN_LIKELY(x27 < x7->sizearray)) {
                        x28 = &x7->array[x27];
                    } else {
                        x28 = luaH_getint(x7, x26);
                    }
                    if (TITAN_UNLIKELY(!ttisboolean(x28))) {
                        titan_runtime_array_type_error(L, 12, LUA_TBOOLEAN, rawtt(x28));
                    }
                    int x29 = bvalue(x28);
                    if (x29) {
                        lua_Integer x30 = intop(+, x18, 1);
                        x18 = x30;
                        lua_Unsigned x31 /* ui */ = ((lua_Unsigned)x18) - 1;
                        TValue * x32 /* slot */;
                        if (TITAN_LIKELY(x31 < x22->sizearray)) {
                            x32 = &x22->array[x31];
                        } else {
                            TValue x33;
                            setivalue(&x33, x31+1);
                            x32 = luaH_newkey(L, x22, &x33);
                        }
                        setivalue(x32, x26);
                        lua_Integer x34 = intop(+, x26, x26);
                        lua_Integer x35 /* start */ = x34;
                        lua_Integer x36 /* finish */ = x1;
                        lua_Integer x37 /* inc */ = x26;
                        while ((x37 >= 0 ? x35 <= x36 : x35 >= x36)) {
                            lua_Integer x38 /* m */ = x35;
                            (void) x38;
                            {
                                lua_Unsigned x39 /* ui */ = ((lua_Unsigned)x38) - 1;
                                TValue * x40 /* slot */;
                                if (TITAN_LIKELY(x39 < x7->sizearray)) {
                                    x40 = &x7->array[x39];
                                } else {
                                    TValue x41;
                                    setivalue(&x41, x39+1);
                                    x40 = luaH_newkey(L, x7, &x41);
                                }
                                setbvalue(x40, 0);
                            }
                            x35 = intop(+, x35, x37);
                        }
                    }
                }
            }
            x23 = intop(+, x23, x25);
        }
        return x22;
    }
}

static int function_sieve_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Table * x2 /* upvalue table */ = hvalue(&x1->upvalue[0]);
    TValue * x3 /* upvalue array */ = x2->array;
    (void)x3;
    StackValue* x4 = L->ci->func;
    int x5 /* nargs */ = cast_int(L->top - (x4 + 1));
    if (TITAN_UNLIKELY(x5 != 1)) {
        titan_runtime_arity_error(L, 1, x5);
    }
    TValue* x6 = s2v(x4 + 1);
    if (TITAN_UNLIKELY(!ttisinteger(x6))) {
        titan_runtime_argument_type_error(L, "N", 1, LUA_TNUMINT, x6);
    }
    lua_Integer x7 = ivalue(s2v(x4 + 1));
    Table * x8 /* ret */ = function_sieve_titan(L, x7);
    sethvalue(L, s2v(L->top), x8);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_sieve_hash(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Table * x1 = luaH_new(L);
    luaH_resizearray(L, x1, 3);
    TValue * x2 = x1->array;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0] , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[1] , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* sieve */
    CClosure* x5 = luaF_newCclosure(L, 1);
    x5->f = function_sieve_lua;
    sethvalue(L, &x5->upvalue[0], x1);
    TValue x6; setclCvalue(L, &x6, x5);
    setobj(L,  &x2[2] , &x6);
    if (iscollectable(&x6) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x6))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x7 = L->top;
    sethvalue(L, s2v(x7), x1); x7++;
    L->top = x7;
    lua_createtable(L, 0, 1);
    lua_pushstring(L, "sieve");
    setobj(L, s2v(L->top),  &x2[2] ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

