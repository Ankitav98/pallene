/*
 *  This implements some manual optimizations that the pallene compiler
 *  currently cannot. See "HANDOPT.txt".
 */

/*
 *  This file also removes all safety tag checks.
 */

/* This file was generated by the Pallene compiler. Do not edit by hand */
/* Indentation and formatting courtesy of pallene/pretty.lua */

#include <string.h>

#include "pallene_core.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

static Table * function_sieve_pallene(
    lua_State * L,
    lua_Integer x1 /* N */
){
    lua_checkstack(L, 1);
    CClosure * x2 = clCvalue(s2v(L->ci->func));
    Udata * x3 /* upvalue table */ = uvalue(&x2->upvalue[0]);
    UValue * x4 /* upvalue array */ = x3->uv;
    (void)x4;
    {
        luaC_condGC(L, {
        }, {
        });
        Table * x5 = luaH_new(L);
        luaH_resizearray(L, x5, 0);
        TValue * x6 = x5->array;
        (void) x6;
        Table * x7 /* is_prime */ = x5;
        lua_Unsigned x8 /* ui */ = ((lua_Unsigned)1) - 1;
        if (PALLENE_UNLIKELY(x8 >= x7->sizearray)) {
            pallene_renormalize_array(L, x7, x8, 3);
        }
        TValue * x9 /* slot */ = &x7->array[x8];
        setbvalue(x9, 0);
        lua_Integer x10 /* start */ = 2;
        lua_Integer x11 /* limit */ = x1;
        lua_Integer x12 /* step */ = 1;
        
        /* BEGIN OPT - bounds for is_prime[n] */
        if (x11 >= x10) {
            lua_Unsigned bound = ((lua_Unsigned)x11) - 1;
            if (PALLENE_UNLIKELY(bound >= x7->sizearray)) {
                pallene_renormalize_array(L, x7, bound, 5);
            }
        }
        /* END OPT */
        while ((x12 >= 0 ? x10 <= x11 : x10 >= x11)) {
            lua_Integer x13 /* n */ = x10;
            (void) x13;
            {
                lua_Unsigned x14 /* ui */ = ((lua_Unsigned)x13) - 1;
                TValue * x15 /* slot */ = &x7->array[x14];
                setbvalue(x15, 1);
            }
            x10 = intop(+, x10, x12);
        }
        lua_Integer x16 /* nprimes */ = 0;
        luaC_condGC(L, {
            StackValue* x17 = L->top;
            sethvalue(L, s2v(x17), x7); x17++;
            L->top = x17;
        }, {
            L->top -= 1;
        });
        Table * x18 = luaH_new(L);
        luaH_resizearray(L, x18, 0);
        TValue * x19 = x18->array;
        (void) x19;
        Table * x20 /* primes */ = x18;
        lua_Integer x21 /* start */ = 1;
        lua_Integer x22 /* limit */ = x1;
        lua_Integer x23 /* step */ = 1;
        
        /* BEGIN OPT - bounds for is_prime[n], is_prime[m]*/
        if (x22 >= x21) {
            lua_Unsigned bound = ((lua_Unsigned)x22) - 1;
            if (PALLENE_UNLIKELY(bound >= x7->sizearray)) {
                pallene_renormalize_array(L, x7, bound, 12);
            }
        }
        /* END OPT */
        while ((x23 >= 0 ? x21 <= x22 : x21 >= x22)) {
            lua_Integer x24 /* n */ = x21;
            (void) x24;
            {
                {
                    lua_Unsigned x25 /* ui */ = ((lua_Unsigned)x24) - 1;
                    const TValue * x26 /* arrslot */ = &x7->array[x25];
                    int x27 = bvalue(x26);
                    if (x27) {
                        lua_Integer x28 = intop(+, x16, 1);
                        x16 = x28;
                        lua_Unsigned x29 /* ui */ = ((lua_Unsigned)x16) - 1;
                        if (PALLENE_UNLIKELY(x29 >= x20->sizearray)) {
                            pallene_renormalize_array(L, x20, x29, 14);
                        }
                        TValue * x30 /* slot */ = &x20->array[x29];
                        setivalue(x30, x24);
                        lua_Integer x31 = intop(+, x24, x24);
                        lua_Integer x32 /* start */ = x31;
                        lua_Integer x33 /* limit */ = x1;
                        lua_Integer x34 /* step */ = x24;
                        while ((x34 >= 0 ? x32 <= x33 : x32 >= x33)) {
                            lua_Integer x35 /* m */ = x32;
                            (void) x35;
                            {
                                lua_Unsigned x36 /* ui */ = ((lua_Unsigned)x35) - 1;
                                TValue * x37 /* slot */ = &x7->array[x36];
                                setbvalue(x37, 0);
                            }
                            x32 = intop(+, x32, x34);
                        }
                    } else {
                    }
                }
            }
            x21 = intop(+, x21, x23);
        }
        return x20;
    }
}

static int function_sieve_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    CClosure * x1 = clCvalue(s2v(L->ci->func));
    Udata * x2 /* upvalue table */ = uvalue(&x1->upvalue[0]);
    UValue * x3 /* upvalue array */ = x2->uv;
    (void)x3;
    StackValue* x4 = L->ci->func;
    lua_Integer x7 = ivalue(s2v(x4 + 1));
    Table * x8 /* ret */ = function_sieve_pallene(L, x7);
    sethvalue(L, s2v(L->top), x8);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_sieve_nocheck(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Udata * x1 = luaS_newudata(L, 0, 4);
    UValue * x2 = x1->uv;
    /* Initialize upvalues */
    /* ------------------- */
    TString * x3 = luaS_new(L, "__index");
    setsvalue(L,  &x2[0].uv , x3);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x3))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x4 = luaS_new(L, "__newindex");
    setsvalue(L,  &x2[1].uv , x4);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    TString * x5 = luaS_new(L, "__metatable");
    setsvalue(L,  &x2[2].uv , x5);
    if (isblack(obj2gco(x1)) && iswhite(obj2gco(x5))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* sieve */
    CClosure* x6 = luaF_newCclosure(L, 1);
    x6->f = function_sieve_lua;
    setuvalue(L, &x6->upvalue[0], x1);
    TValue x7; setclCvalue(L, &x7, x6);
    setobj(L,  &x2[3].uv , &x7);
    if (iscollectable(&x7) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x7))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table */
    /* -------------------- */
    StackValue* x8 = L->top;
    setuvalue(L, s2v(x8), x1); x8++;
    L->top = x8;
    lua_createtable(L, 0, 1);
    lua_pushstring(L, "sieve");
    setobj(L, s2v(L->top),  &x2[3].uv ); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

